
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: ./nb/HMM.ipynb

import sys
if __name__ == '__main__': sys.path.append('..')
import exp.common as common

import operator
def get_max_tuple(d):
    assert isinstance(d, dict)
    return max(d.items(), key=operator.itemgetter(1))


def viterbi(nodes,trans_p, initial_state = None, return_max = True, start_p = None):
    """
    nodes: array, [{"<TAG>": <float>}]
    trans_p: dict, {"<TAG_A>": {"TAG_B": <float>}}, TAG_A -> TAG-B
    return_max=True: bool, set to False if your want to avoid ill endding tag and find your own.
    initial_state=None: None or list to avoid impossible starting tags
    start_p: P(o1), may be nessary
    all float number in log form
    """
    if initial_state is None:
        initial_state = nodes[0]
        nodes = nodes[1:]

    if start_p:
        for k in initial_state:
            if k in start_p:
                initial_state[k] *= start_p[k]

    path_score = initial_state


    for node in nodes:
        new_path_score = {}
        for t,v in node.items():
            t_new_path_score = {}

            for path, score in path_score.items():

                last_t = path[-1]
                new_path = path + t

                tran = trans_p[last_t].get(t, None)
                if tran is None:
                # 不合法的转移
                    pass
                else :
                    t_new_path_score[new_path] = score + tran + v

            new_path_score.__setitem__(*get_max_tuple(t_new_path_score))
        path_score = new_path_score
    return get_max_tuple(path_score) if return_max else path_score

def decode_seq_tags(seq, tags, splitter_tags=['S', 'E'], word_spliter='|'):
    ret = ''
    splitter_tags = set(splitter_tags)
    for c, t in zip(seq,tags):

        if t in splitter_tags:
            ret += c
            ret += word_spliter
        else :
            ret += c

    if tags[-1] in splitter_tags:
        return ret[:-1]

    return ret



from math import log
def get_cal_nodes_by_dict(dictionary):
    """
    dictionary: {<TAG>:{<char>:freq}}
    """

    dictionary_sum = dict(map(lambda tp:(tp[0], sum(tp[1].values())), dictionary.items()))
    def cal_nodes(sentence):
        """
        sentence: str,
        # 加1平滑
        return: [c在给定<TAG>下对数概率{<TAG>:float} for c in sentence]
        """
        nodes = []
        for w in s:
            d = {}
            for (t, v) in dictionary.items():
                # 加1平滑
                d[t] = log(v.get(w, 0)+1) - log(dictionary_sum[t])
            nodes.append(d)
        return nodes
    return cal_nodes
#         print(t, v[w], v[w]/dictionary_sum[t], log(v[w]) - log(dictionary_sum[t]))

